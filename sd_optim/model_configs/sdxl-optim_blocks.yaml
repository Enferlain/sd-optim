# Filename: sdxl-optim_blocks.yaml
# Place this in sd_optim/model_configs/ or your folder of choice via config
# Remember to register it if placed outside sd-mecha!

identifier: sdxl-optim_blocks # Unique identifier for this custom block configuration

components:
  unet: # Component name matching the base sdxl-sgm config
    # Keys within this component are now our defined blocks
    # Prefixes based on 'model.diffusion_model.'
    UNET_IN00: {shape: [], dtype: float32, optional: true}
    UNET_IN01: {shape: [], dtype: float32, optional: true}
    UNET_IN02: {shape: [], dtype: float32, optional: true}
    UNET_IN03: {shape: [], dtype: float32, optional: true}
    UNET_IN04: {shape: [], dtype: float32, optional: true}
    UNET_IN05: {shape: [], dtype: float32, optional: true}
    UNET_IN06: {shape: [], dtype: float32, optional: true}
    UNET_IN07: {shape: [], dtype: float32, optional: true}
    UNET_IN08: {shape: [], dtype: float32, optional: true}
    UNET_MID00: {shape: [], dtype: float32, optional: true}  # Middle block
    UNET_OUT00: {shape: [], dtype: float32, optional: true}
    UNET_OUT01: {shape: [], dtype: float32, optional: true}
    UNET_OUT02: {shape: [], dtype: float32, optional: true}
    UNET_OUT03: {shape: [], dtype: float32, optional: true}
    UNET_OUT04: {shape: [], dtype: float32, optional: true}
    UNET_OUT05: {shape: [], dtype: float32, optional: true}
    UNET_OUT06: {shape: [], dtype: float32, optional: true}
    UNET_OUT07: {shape: [], dtype: float32, optional: true}
    UNET_OUT08: {shape: [], dtype: float32, optional: true}
    UNET_TIME_EMBED: {shape: [], dtype: float32, optional: true}  # For time_embed keys
    UNET_LABEL_EMBED: {shape: [], dtype: float32, optional: true} # For label_embed keys
    UNET_OUT_FINAL: {shape: [], dtype: float32, optional: true}   # For final 'model.diffusion_model.out.*' keys
    UNET_ELSE: {shape: [], dtype: float32, optional: true}        # Fallback for unet keys not matching above

  clip_l: # Component name matching the base sdxl-sgm config ('txt')
    # Prefixes based on 'conditioner.embedders.0.transformer.text_model.'
    CLIP_L_IN00: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN01: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN02: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN03: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN04: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN05: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN06: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN07: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN08: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN09: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN10: {shape: [], dtype: float32, optional: true}
    CLIP_L_IN11: {shape: [], dtype: float32, optional: true}
    CLIP_L_EMBEDDING: {shape: [], dtype: float32, optional: true}     # For embedding keys
    CLIP_L_FINAL_NORM: {shape: [], dtype: float32, optional: true} # For final_layer_norm keys
    CLIP_L_ELSE: {shape: [], dtype: float32, optional: true}       # Fallback for clip_l keys

  clip_g: # Component name matching the base sdxl-sgm config ('txt2')
    # Prefixes based on 'conditioner.embedders.1.model.'
    CLIP_G_IN00: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN01: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN02: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN03: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN04: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN05: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN06: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN07: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN08: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN09: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN10: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN11: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN12: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN13: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN14: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN15: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN16: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN17: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN18: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN19: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN20: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN21: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN22: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN23: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN24: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN25: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN26: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN27: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN28: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN29: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN30: {shape: [], dtype: float32, optional: true}
    CLIP_G_IN31: {shape: [], dtype: float32, optional: true}
    CLIP_G_LN_FINAL: {shape: [], dtype: float32, optional: true}       # For ln_final keys
    CLIP_G_TEXT_PROJECTION: {shape: [], dtype: float32, optional: true}   # For text_projection keys
    CLIP_G_EMBEDDING: {shape: [], dtype: float32, optional: true} # For token_embedding keys
    CLIP_G_ELSE: {shape: [], dtype: float32, optional: true}       # Fallback for clip_g keys

  vae: # Component name matching the base sdxl-sgm config
    # Prefixes based on 'first_stage_model.' - Replaced VAE_ALL with granular blocks
    VAE_ENCODER_IN: {shape: [], dtype: float32, optional: true}      # encoder.conv_in
    VAE_ENCODER_DOWN: {shape: [], dtype: float32, optional: true}    # encoder.down.*
    VAE_ENCODER_MID: {shape: [], dtype: float32, optional: true}     # encoder.mid.*
    VAE_ENCODER_OUT: {shape: [], dtype: float32, optional: true}     # encoder.norm_out, encoder.conv_out
    VAE_QUANT: {shape: [], dtype: float32, optional: true}           # quant_conv, post_quant_conv
    VAE_DECODER_IN: {shape: [], dtype: float32, optional: true}      # decoder.conv_in
    VAE_DECODER_MID: {shape: [], dtype: float32, optional: true}     # decoder.mid.*
    VAE_DECODER_UP: {shape: [], dtype: float32, optional: true}      # decoder.up.*
    VAE_DECODER_OUT: {shape: [], dtype: float32, optional: true}     # decoder.norm_out, decoder.conv_out
    VAE_ELSE: {shape: [], dtype: float32, optional: true}            # Fallback for any unhandled VAE keys
